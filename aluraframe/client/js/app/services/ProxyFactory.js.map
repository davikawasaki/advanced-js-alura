{"version":3,"sources":["../../app-es6/services/ProxyFactory.js"],"names":["ProxyFactory","obj","props","action","Proxy","get","target","prop","receiver","includes","_isFunction","console","log","valueReturn","Reflect","apply","arguments","set","value","proxyReturn","fn","Function"],"mappings":";;;;;;;;IAAMA,Y;;;;;;;+BAEYC,G,EAAKC,K,EAAOC,M,EAAQ;AAC9B,mBAAO,IAAIC,KAAJ,CAAUH,GAAV,EAAe;AAClBI,mBADkB,eACdC,MADc,EACNC,IADM,EACAC,QADA,EACU;AACxB;AACA,wBAAGN,MAAMO,QAAN,CAAeF,IAAf,KAAwBP,aAAaU,WAAb,CAAyBJ,OAAOC,IAAP,CAAzB,CAA3B,EAAmE;AAC/D;AACA;AACA,+BAAO,YAAW;AACdI,oCAAQC,GAAR,0BAAmCL,IAAnC;AACA;AACA;AACA,gCAAIM,cAAcC,QAAQC,KAAR,CAAcT,OAAOC,IAAP,CAAd,EAA4BD,MAA5B,EAAoCU,SAApC,CAAlB;;AAEA;AACA;AACAb,mCAAOG,MAAP;;AAEA,mCAAOO,WAAP;AACH,yBAXD;AAYH;;AAED;AACA,2BAAOC,QAAQT,GAAR,CAAYC,MAAZ,EAAoBC,IAApB,EAA0BC,QAA1B,CAAP;AACH,iBAtBiB;AAwBlBS,mBAxBkB,eAwBdX,MAxBc,EAwBNC,IAxBM,EAwBAW,KAxBA,EAwBOV,QAxBP,EAwBiB;;AAE/B,wBAAIW,cAAcL,QAAQG,GAAR,CAAYX,MAAZ,EAAoBC,IAApB,EAA0BW,KAA1B,EAAiCV,QAAjC,CAAlB;AACA,wBAAGN,MAAMO,QAAN,CAAeF,IAAf,CAAH,EAAyB;AACrB;AACA;AACAJ,+BAAOG,MAAP;AACH;AACD,2BAAOa,WAAP;AACH;AAjCiB,aAAf,CAAP;AAmCH;;;oCAEkBC,E,EAAI;AACnB,mBAAO,QAAOA,EAAP,yCAAOA,EAAP,cAAqBC,QAArB,yCAAqBA,QAArB,EAAP;AACH","file":"ProxyFactory.js","sourcesContent":["class ProxyFactory {\n\n    static create(obj, props, action) {\n        return new Proxy(obj, {\n            get(target, prop, receiver) {\n                // Alternative: intercepting methods\n                if(props.includes(prop) && ProxyFactory._isFunction(target[prop])) {\n                    // Changing object function on proxy with a new function, letting the original one intact\n                    // Scope needs to be dynamic\n                    return function() {\n                        console.log(`Intercepting method ${prop}`);\n                        // Calling the original object method from target with arguments passed within his own scope\n                        // Arguments is a implicit variable with access to method args when the method is called\n                        let valueReturn = Reflect.apply(target[prop], target, arguments);\n\n                        // Update view with controller scope and model, which is target\n                        // JS method execution order: first get method reference, then apply it with params\n                        action(target);\n\n                        return valueReturn;\n                    }\n                }\n\n                // Return property value of target\n                return Reflect.get(target, prop, receiver);\n            },\n\n            set(target, prop, value, receiver) {\n\n                let proxyReturn = Reflect.set(target, prop, value, receiver);\n                if(props.includes(prop)) {\n                    // Set new value for prop before updating view\n                    // target[prop] = value;\n                    action(target);\n                }\n                return proxyReturn;\n            }\n        });\n    }\n\n    static _isFunction(fn) {\n        return typeof(fn) == typeof(Function);\n    }\n\n}"]}