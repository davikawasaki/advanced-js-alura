{"version":3,"sources":["../../app-es6/services/ProxyFactory.js"],"names":["ProxyFactory","obj","props","action","Proxy","get","target","prop","receiver","includes","_isFunction","console","log","valueReturn","Reflect","apply","arguments","set","value","proxyReturn","fn","Function"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oCAAaA,Y;;;;;;;2CAEKC,G,EAAKC,K,EAAOC,M,EAAQ;AAC9B,+BAAO,IAAIC,KAAJ,CAAUH,GAAV,EAAe;AAClBI,+BADkB,eACdC,MADc,EACNC,IADM,EACAC,QADA,EACU;AACxB;AACA,oCAAGN,MAAMO,QAAN,CAAeF,IAAf,KAAwBP,aAAaU,WAAb,CAAyBJ,OAAOC,IAAP,CAAzB,CAA3B,EAAmE;AAC/D;AACA;AACA,2CAAO,YAAW;AACdI,gDAAQC,GAAR,0BAAmCL,IAAnC;AACA;AACA;AACA,4CAAIM,cAAcC,QAAQC,KAAR,CAAcT,OAAOC,IAAP,CAAd,EAA4BD,MAA5B,EAAoCU,SAApC,CAAlB;;AAEA;AACA;AACAb,+CAAOG,MAAP;;AAEA,+CAAOO,WAAP;AACH,qCAXD;AAYH;;AAED;AACA,uCAAOC,QAAQT,GAAR,CAAYC,MAAZ,EAAoBC,IAApB,EAA0BC,QAA1B,CAAP;AACH,6BAtBiB;AAwBlBS,+BAxBkB,eAwBdX,MAxBc,EAwBNC,IAxBM,EAwBAW,KAxBA,EAwBOV,QAxBP,EAwBiB;;AAE/B,oCAAIW,cAAcL,QAAQG,GAAR,CAAYX,MAAZ,EAAoBC,IAApB,EAA0BW,KAA1B,EAAiCV,QAAjC,CAAlB;AACA,oCAAGN,MAAMO,QAAN,CAAeF,IAAf,CAAH,EAAyB;AACrB;AACA;AACAJ,2CAAOG,MAAP;AACH;AACD,uCAAOa,WAAP;AACH;AAjCiB,yBAAf,CAAP;AAmCH;;;gDAEkBC,E,EAAI;AACnB,+BAAO,QAAOA,EAAP,yCAAOA,EAAP,cAAqBC,QAArB,yCAAqBA,QAArB,EAAP;AACH","file":"ProxyFactory.js","sourcesContent":["export class ProxyFactory {\n\n    static create(obj, props, action) {\n        return new Proxy(obj, {\n            get(target, prop, receiver) {\n                // Alternative: intercepting methods\n                if(props.includes(prop) && ProxyFactory._isFunction(target[prop])) {\n                    // Changing object function on proxy with a new function, letting the original one intact\n                    // Scope needs to be dynamic\n                    return function() {\n                        console.log(`Intercepting method ${prop}`);\n                        // Calling the original object method from target with arguments passed within his own scope\n                        // Arguments is a implicit variable with access to method args when the method is called\n                        let valueReturn = Reflect.apply(target[prop], target, arguments);\n\n                        // Update view with controller scope and model, which is target\n                        // JS method execution order: first get method reference, then apply it with params\n                        action(target);\n\n                        return valueReturn;\n                    }\n                }\n\n                // Return property value of target\n                return Reflect.get(target, prop, receiver);\n            },\n\n            set(target, prop, value, receiver) {\n\n                let proxyReturn = Reflect.set(target, prop, value, receiver);\n                if(props.includes(prop)) {\n                    // Set new value for prop before updating view\n                    // target[prop] = value;\n                    action(target);\n                }\n                return proxyReturn;\n            }\n        });\n    }\n\n    static _isFunction(fn) {\n        return typeof(fn) == typeof(Function);\n    }\n\n}"]}